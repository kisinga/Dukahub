// Autogenerated by github.com/snonky/pocketbase-gogen. Do not edit.
package models

import (
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/tools/types"
)

type Admins struct {
	core.BaseRecordProxy
}

func (p *Admins) CollectionName() string {
	return "admins"
}

func (p *Admins) Username() string {
	return p.GetString("username")
}

func (p *Admins) SetUsername(username string) {
	p.Set("username", username)
}

func (p *Admins) Name() string {
	return p.GetString("name")
}

func (p *Admins) SetName(name string) {
	p.Set("name", name)
}

func (p *Admins) Avatar() string {
	return p.GetString("avatar")
}

func (p *Admins) SetAvatar(avatar string) {
	p.Set("avatar", avatar)
}

func (p *Admins) Company() []*Companies {
	rels := p.ExpandedAll("company")
	proxies := make([]*Companies, len(rels))
	for i := range len(rels) {
		proxies[i] = &Companies{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Admins) SetCompany(company []*Companies) {
	records := make([]*core.Record, len(company))
	ids := make([]string, len(company))
	for i, r := range company {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("company", ids)
	e := p.Expand()
	e["company"] = records
	p.SetExpand(e)
}

func (p *Admins) DefaultCompany() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("defaultCompany"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Admins) SetDefaultCompany(defaultCompany *Companies) {
	var id string
	if defaultCompany != nil {
		id = defaultCompany.Id
	}
	p.Record.Set("defaultCompany", id)
	e := p.Expand()
	if defaultCompany != nil {
		e["defaultCompany"] = defaultCompany.Record
	} else {
		delete(e, "defaultCompany")
	}
	p.SetExpand(e)
}

func (p *Admins) Level() float64 {
	return p.GetFloat("level")
}

func (p *Admins) SetLevel(level float64) {
	p.Set("level", level)
}

func (p *Admins) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Admins) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Admins) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Admins) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type DailyStockTakes struct {
	core.BaseRecordProxy
}

func (p *DailyStockTakes) CollectionName() string {
	return "daily_stock_takes"
}

func (p *DailyStockTakes) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyStockTakes) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *DailyStockTakes) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyStockTakes) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *DailyStockTakes) User() *Admins {
	var proxy *Admins
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Admins{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyStockTakes) SetUser(user *Admins) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *DailyStockTakes) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *DailyStockTakes) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *DailyStockTakes) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyStockTakes) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *DailyStockTakes) OpeningBal() float64 {
	return p.GetFloat("opening_bal")
}

func (p *DailyStockTakes) SetOpeningBal(openingBal float64) {
	p.Set("opening_bal", openingBal)
}

func (p *DailyStockTakes) ClosingBal() float64 {
	return p.GetFloat("closing_bal")
}

func (p *DailyStockTakes) SetClosingBal(closingBal float64) {
	p.Set("closing_bal", closingBal)
}

func (p *DailyStockTakes) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *DailyStockTakes) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *DailyStockTakes) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *DailyStockTakes) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type DailyAccounts struct {
	core.BaseRecordProxy
}

func (p *DailyAccounts) CollectionName() string {
	return "daily_accounts"
}

func (p *DailyAccounts) OpeningBal() int {
	return p.GetInt("opening_bal")
}

func (p *DailyAccounts) SetOpeningBal(openingBal int) {
	p.Set("opening_bal", openingBal)
}

func (p *DailyAccounts) ClosingBal() int {
	return p.GetInt("closing_bal")
}

func (p *DailyAccounts) SetClosingBal(closingBal int) {
	p.Set("closing_bal", closingBal)
}

func (p *DailyAccounts) Account() *CompanyAccounts {
	var proxy *CompanyAccounts
	if rel := p.ExpandedOne("account"); rel != nil {
		proxy = &CompanyAccounts{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyAccounts) SetAccount(account *CompanyAccounts) {
	var id string
	if account != nil {
		id = account.Id
	}
	p.Record.Set("account", id)
	e := p.Expand()
	if account != nil {
		e["account"] = account.Record
	} else {
		delete(e, "account")
	}
	p.SetExpand(e)
}

func (p *DailyAccounts) Notes() string {
	return p.GetString("notes")
}

func (p *DailyAccounts) SetNotes(notes string) {
	p.Set("notes", notes)
}

func (p *DailyAccounts) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyAccounts) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *DailyAccounts) User() *Admins {
	var proxy *Admins
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Admins{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyAccounts) SetUser(user *Admins) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *DailyAccounts) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *DailyAccounts) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *DailyAccounts) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *DailyAccounts) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *DailyAccounts) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *DailyAccounts) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type AccountTypes struct {
	core.BaseRecordProxy
}

func (p *AccountTypes) CollectionName() string {
	return "account_types"
}

func (p *AccountTypes) Name() string {
	return p.GetString("name")
}

func (p *AccountTypes) SetName(name string) {
	p.Set("name", name)
}

func (p *AccountTypes) Icons() []string {
	return p.GetStringSlice("icons")
}

func (p *AccountTypes) SetIcons(icons []string) {
	p.Set("icons", icons)
}

func (p *AccountTypes) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *AccountTypes) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *AccountTypes) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *AccountTypes) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Skus struct {
	core.BaseRecordProxy
}

func (p *Skus) CollectionName() string {
	return "skus"
}

func (p *Skus) Name() string {
	return p.GetString("name")
}

func (p *Skus) SetName(name string) {
	p.Set("name", name)
}

func (p *Skus) Initials() string {
	return p.GetString("initials")
}

func (p *Skus) SetInitials(initials string) {
	p.Set("initials", initials)
}

func (p *Skus) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Skus) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Skus) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Skus) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Products struct {
	core.BaseRecordProxy
}

func (p *Products) CollectionName() string {
	return "products"
}

func (p *Products) Name() string {
	return p.GetString("name")
}

func (p *Products) SetName(name string) {
	p.Set("name", name)
}

func (p *Products) Skus() []*Skus {
	rels := p.ExpandedAll("skus")
	proxies := make([]*Skus, len(rels))
	for i := range len(rels) {
		proxies[i] = &Skus{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Products) SetSkus(skus []*Skus) {
	records := make([]*core.Record, len(skus))
	ids := make([]string, len(skus))
	for i, r := range skus {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("skus", ids)
	e := p.Expand()
	e["skus"] = records
	p.SetExpand(e)
}

func (p *Products) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Products) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Products) Photos() []string {
	return p.GetStringSlice("photos")
}

func (p *Products) SetPhotos(photos []string) {
	p.Set("photos", photos)
}

func (p *Products) Category() []*ProductCategories {
	rels := p.ExpandedAll("category")
	proxies := make([]*ProductCategories, len(rels))
	for i := range len(rels) {
		proxies[i] = &ProductCategories{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Products) SetCategory(category []*ProductCategories) {
	records := make([]*core.Record, len(category))
	ids := make([]string, len(category))
	for i, r := range category {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("category", ids)
	e := p.Expand()
	e["category"] = records
	p.SetExpand(e)
}

func (p *Products) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Products) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Products) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Products) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Partners struct {
	core.BaseRecordProxy
}

func (p *Partners) CollectionName() string {
	return "partners"
}

func (p *Partners) Name() string {
	return p.GetString("name")
}

func (p *Partners) SetName(name string) {
	p.Set("name", name)
}

func (p *Partners) Phone() string {
	return p.GetString("phone")
}

func (p *Partners) SetPhone(phone string) {
	p.Set("phone", phone)
}

func (p *Partners) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Partners) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Partners) Balance() float64 {
	return p.GetFloat("balance")
}

func (p *Partners) SetBalance(balance float64) {
	p.Set("balance", balance)
}

func (p *Partners) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Partners) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Partners) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Partners) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type StatusSelectType int

const (
	Paid StatusSelectType = iota
	Partial
	Pending
)

var zzStatusSelectTypeSelectNameMap = map[string]StatusSelectType{
	"paid":    0,
	"partial": 1,
	"pending": 2,
}
var zzStatusSelectTypeSelectIotaMap = map[StatusSelectType]string{
	0: "paid",
	1: "partial",
	2: "pending",
}

type TypeSelectType int

const (
	Sale TypeSelectType = iota
	Purchase
)

var zzTypeSelectTypeSelectNameMap = map[string]TypeSelectType{
	"sale":     0,
	"purchase": 1,
}
var zzTypeSelectTypeSelectIotaMap = map[TypeSelectType]string{
	0: "sale",
	1: "purchase",
}

type Invoices struct {
	core.BaseRecordProxy
}

func (p *Invoices) CollectionName() string {
	return "invoices"
}

func (p *Invoices) Partner() *Partners {
	var proxy *Partners
	if rel := p.ExpandedOne("partner"); rel != nil {
		proxy = &Partners{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Invoices) SetPartner(partner *Partners) {
	var id string
	if partner != nil {
		id = partner.Id
	}
	p.Record.Set("partner", id)
	e := p.Expand()
	if partner != nil {
		e["partner"] = partner.Record
	} else {
		delete(e, "partner")
	}
	p.SetExpand(e)
}

func (p *Invoices) Amount() float64 {
	return p.GetFloat("amount")
}

func (p *Invoices) SetAmount(amount float64) {
	p.Set("amount", amount)
}

func (p *Invoices) Status() StatusSelectType {
	option := p.GetString("status")
	i, ok := zzStatusSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Invoices) SetStatus(status StatusSelectType) {
	i, ok := zzStatusSelectTypeSelectIotaMap[status]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("status", i)
}

func (p *Invoices) Bal() float64 {
	return p.GetFloat("bal")
}

func (p *Invoices) SetBal(bal float64) {
	p.Set("bal", bal)
}

func (p *Invoices) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Invoices) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Invoices) User() *Admins {
	var proxy *Admins
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Admins{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Invoices) SetUser(user *Admins) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *Invoices) Type() TypeSelectType {
	option := p.GetString("type")
	i, ok := zzTypeSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Invoices) SetType(type_ TypeSelectType) {
	i, ok := zzTypeSelectTypeSelectIotaMap[type_]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("type", i)
}

func (p *Invoices) Transactions() []*Transactions {
	rels := p.ExpandedAll("transactions")
	proxies := make([]*Transactions, len(rels))
	for i := range len(rels) {
		proxies[i] = &Transactions{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Invoices) SetTransactions(transactions []*Transactions) {
	records := make([]*core.Record, len(transactions))
	ids := make([]string, len(transactions))
	for i, r := range transactions {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("transactions", ids)
	e := p.Expand()
	e["transactions"] = records
	p.SetExpand(e)
}

func (p *Invoices) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *Invoices) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *Invoices) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Invoices) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Invoices) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Invoices) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Purchases struct {
	core.BaseRecordProxy
}

func (p *Purchases) CollectionName() string {
	return "purchases"
}

func (p *Purchases) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *Purchases) Quantity() float64 {
	return p.GetFloat("quantity")
}

func (p *Purchases) SetQuantity(quantity float64) {
	p.Set("quantity", quantity)
}

func (p *Purchases) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *Purchases) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Purchases) User() *Admins {
	var proxy *Admins
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Admins{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetUser(user *Admins) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *Purchases) Invoice() *Invoices {
	var proxy *Invoices
	if rel := p.ExpandedOne("invoice"); rel != nil {
		proxy = &Invoices{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetInvoice(invoice *Invoices) {
	var id string
	if invoice != nil {
		id = invoice.Id
	}
	p.Record.Set("invoice", id)
	e := p.Expand()
	if invoice != nil {
		e["invoice"] = invoice.Record
	} else {
		delete(e, "invoice")
	}
	p.SetExpand(e)
}

func (p *Purchases) Transaction() *Transactions {
	var proxy *Transactions
	if rel := p.ExpandedOne("transaction"); rel != nil {
		proxy = &Transactions{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetTransaction(transaction *Transactions) {
	var id string
	if transaction != nil {
		id = transaction.Id
	}
	p.Record.Set("transaction", id)
	e := p.Expand()
	if transaction != nil {
		e["transaction"] = transaction.Record
	} else {
		delete(e, "transaction")
	}
	p.SetExpand(e)
}

func (p *Purchases) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *Purchases) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *Purchases) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Purchases) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Purchases) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Purchases) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Companies struct {
	core.BaseRecordProxy
}

func (p *Companies) CollectionName() string {
	return "companies"
}

func (p *Companies) Logo() string {
	return p.GetString("logo")
}

func (p *Companies) SetLogo(logo string) {
	p.Set("logo", logo)
}

func (p *Companies) Location() string {
	return p.GetString("location")
}

func (p *Companies) SetLocation(location string) {
	p.Set("location", location)
}

func (p *Companies) Name() string {
	return p.GetString("name")
}

func (p *Companies) SetName(name string) {
	p.Set("name", name)
}

func (p *Companies) Phone() string {
	return p.GetString("phone")
}

func (p *Companies) SetPhone(phone string) {
	p.Set("phone", phone)
}

func (p *Companies) AdminConfig() string {
	return p.GetString("admin_config")
}

func (p *Companies) SetAdminConfig(adminConfig string) {
	p.Set("admin_config", adminConfig)
}

func (p *Companies) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Companies) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Companies) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Companies) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type CompanyAccounts struct {
	core.BaseRecordProxy
}

func (p *CompanyAccounts) CollectionName() string {
	return "company_accounts"
}

func (p *CompanyAccounts) AccountNumber() string {
	return p.GetString("account_number")
}

func (p *CompanyAccounts) SetAccountNumber(accountNumber string) {
	p.Set("account_number", accountNumber)
}

func (p *CompanyAccounts) Name() string {
	return p.GetString("name")
}

func (p *CompanyAccounts) SetName(name string) {
	p.Set("name", name)
}

func (p *CompanyAccounts) Type() *AccountTypes {
	var proxy *AccountTypes
	if rel := p.ExpandedOne("type"); rel != nil {
		proxy = &AccountTypes{}
		proxy.Record = rel
	}
	return proxy
}

func (p *CompanyAccounts) SetType(type_ *AccountTypes) {
	var id string
	if type_ != nil {
		id = type_.Id
	}
	p.Record.Set("type", id)
	e := p.Expand()
	if type_ != nil {
		e["type"] = type_.Record
	} else {
		delete(e, "type")
	}
	p.SetExpand(e)
}

func (p *CompanyAccounts) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *CompanyAccounts) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *CompanyAccounts) Bal() float64 {
	return p.GetFloat("bal")
}

func (p *CompanyAccounts) SetBal(bal float64) {
	p.Set("bal", bal)
}

func (p *CompanyAccounts) IconId() int {
	return p.GetInt("icon_id")
}

func (p *CompanyAccounts) SetIconId(iconId int) {
	p.Set("icon_id", iconId)
}

func (p *CompanyAccounts) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *CompanyAccounts) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *CompanyAccounts) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *CompanyAccounts) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type TypeSelectType2 int

const (
	Debit TypeSelectType2 = iota
	Credit
)

var zzTypeSelectType2SelectNameMap = map[string]TypeSelectType2{
	"debit":  0,
	"credit": 1,
}
var zzTypeSelectType2SelectIotaMap = map[TypeSelectType2]string{
	0: "debit",
	1: "credit",
}

type Transactions struct {
	core.BaseRecordProxy
}

func (p *Transactions) CollectionName() string {
	return "transactions"
}

func (p *Transactions) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Transactions) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Transactions) Account() *CompanyAccounts {
	var proxy *CompanyAccounts
	if rel := p.ExpandedOne("account"); rel != nil {
		proxy = &CompanyAccounts{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Transactions) SetAccount(account *CompanyAccounts) {
	var id string
	if account != nil {
		id = account.Id
	}
	p.Record.Set("account", id)
	e := p.Expand()
	if account != nil {
		e["account"] = account.Record
	} else {
		delete(e, "account")
	}
	p.SetExpand(e)
}

func (p *Transactions) Type() TypeSelectType2 {
	option := p.GetString("type")
	i, ok := zzTypeSelectType2SelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Transactions) SetType(type_ TypeSelectType2) {
	i, ok := zzTypeSelectType2SelectIotaMap[type_]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("type", i)
}

func (p *Transactions) Amount() float64 {
	return p.GetFloat("amount")
}

func (p *Transactions) SetAmount(amount float64) {
	p.Set("amount", amount)
}

func (p *Transactions) TransactionId() string {
	return p.GetString("transaction_id")
}

func (p *Transactions) SetTransactionId(transactionId string) {
	p.Set("transaction_id", transactionId)
}

func (p *Transactions) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *Transactions) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *Transactions) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Transactions) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Transactions) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Transactions) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Sales struct {
	core.BaseRecordProxy
}

func (p *Sales) CollectionName() string {
	return "sales"
}

func (p *Sales) Amount() float64 {
	return p.GetFloat("amount")
}

func (p *Sales) SetAmount(amount float64) {
	p.Set("amount", amount)
}

func (p *Sales) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Sales) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *Sales) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("Product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Sales) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("Product", id)
	e := p.Expand()
	if product != nil {
		e["Product"] = product.Record
	} else {
		delete(e, "Product")
	}
	p.SetExpand(e)
}

func (p *Sales) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Sales) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Sales) Invoice() *Invoices {
	var proxy *Invoices
	if rel := p.ExpandedOne("invoice"); rel != nil {
		proxy = &Invoices{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Sales) SetInvoice(invoice *Invoices) {
	var id string
	if invoice != nil {
		id = invoice.Id
	}
	p.Record.Set("invoice", id)
	e := p.Expand()
	if invoice != nil {
		e["invoice"] = invoice.Record
	} else {
		delete(e, "invoice")
	}
	p.SetExpand(e)
}

func (p *Sales) Transaction() []*Transactions {
	rels := p.ExpandedAll("transaction")
	proxies := make([]*Transactions, len(rels))
	for i := range len(rels) {
		proxies[i] = &Transactions{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Sales) SetTransaction(transaction []*Transactions) {
	records := make([]*core.Record, len(transaction))
	ids := make([]string, len(transaction))
	for i, r := range transaction {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("transaction", ids)
	e := p.Expand()
	e["transaction"] = records
	p.SetExpand(e)
}

func (p *Sales) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *Sales) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *Sales) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Sales) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Sales) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Sales) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Expenses struct {
	core.BaseRecordProxy
}

func (p *Expenses) CollectionName() string {
	return "expenses"
}

func (p *Expenses) Amount() float64 {
	return p.GetFloat("amount")
}

func (p *Expenses) SetAmount(amount float64) {
	p.Set("amount", amount)
}

func (p *Expenses) Purpose() string {
	return p.GetString("purpose")
}

func (p *Expenses) SetPurpose(purpose string) {
	p.Set("purpose", purpose)
}

func (p *Expenses) Transaction() *Transactions {
	var proxy *Transactions
	if rel := p.ExpandedOne("transaction"); rel != nil {
		proxy = &Transactions{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Expenses) SetTransaction(transaction *Transactions) {
	var id string
	if transaction != nil {
		id = transaction.Id
	}
	p.Record.Set("transaction", id)
	e := p.Expand()
	if transaction != nil {
		e["transaction"] = transaction.Record
	} else {
		delete(e, "transaction")
	}
	p.SetExpand(e)
}

func (p *Expenses) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Expenses) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Expenses) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Expenses) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type StatusSelectType2 int

const (
	Open StatusSelectType2 = iota
	Closed
)

var zzStatusSelectType2SelectNameMap = map[string]StatusSelectType2{
	"open":   0,
	"closed": 1,
}
var zzStatusSelectType2SelectIotaMap = map[StatusSelectType2]string{
	0: "open",
	1: "closed",
}

type OpenCloseDetails struct {
	core.BaseRecordProxy
}

func (p *OpenCloseDetails) CollectionName() string {
	return "open_close_details"
}

func (p *OpenCloseDetails) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *OpenCloseDetails) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *OpenCloseDetails) Status() StatusSelectType2 {
	option := p.GetString("status")
	i, ok := zzStatusSelectType2SelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *OpenCloseDetails) SetStatus(status StatusSelectType2) {
	i, ok := zzStatusSelectType2SelectIotaMap[status]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("status", i)
}

func (p *OpenCloseDetails) OpenTime() types.DateTime {
	return p.GetDateTime("open_time")
}

func (p *OpenCloseDetails) SetOpenTime(openTime types.DateTime) {
	p.Set("open_time", openTime)
}

func (p *OpenCloseDetails) CloseTime() types.DateTime {
	return p.GetDateTime("close_time")
}

func (p *OpenCloseDetails) SetCloseTime(closeTime types.DateTime) {
	p.Set("close_time", closeTime)
}

func (p *OpenCloseDetails) User() *Admins {
	var proxy *Admins
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Admins{}
		proxy.Record = rel
	}
	return proxy
}

func (p *OpenCloseDetails) SetUser(user *Admins) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *OpenCloseDetails) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *OpenCloseDetails) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *OpenCloseDetails) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *OpenCloseDetails) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type ProductSkuFigures struct {
	core.BaseRecordProxy
}

func (p *ProductSkuFigures) CollectionName() string {
	return "product_sku_figures"
}

func (p *ProductSkuFigures) Bal() float64 {
	return p.GetFloat("bal")
}

func (p *ProductSkuFigures) SetBal(bal float64) {
	p.Set("bal", bal)
}

func (p *ProductSkuFigures) Price() float64 {
	return p.GetFloat("price")
}

func (p *ProductSkuFigures) SetPrice(price float64) {
	p.Set("price", price)
}

func (p *ProductSkuFigures) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *ProductSkuFigures) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *ProductSkuFigures) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *ProductSkuFigures) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *ProductSkuFigures) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *ProductSkuFigures) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *ProductSkuFigures) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *ProductSkuFigures) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Models struct {
	core.BaseRecordProxy
}

func (p *Models) CollectionName() string {
	return "models"
}

func (p *Models) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Models) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Models) Metadata() string {
	return p.GetString("metadata")
}

func (p *Models) SetMetadata(metadata string) {
	p.Set("metadata", metadata)
}

func (p *Models) Model() string {
	return p.GetString("model")
}

func (p *Models) SetModel(model string) {
	p.Set("model", model)
}

func (p *Models) Weights() string {
	return p.GetString("weights")
}

func (p *Models) SetWeights(weights string) {
	p.Set("weights", weights)
}

func (p *Models) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Models) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Models) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Models) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type ProductCategories struct {
	core.BaseRecordProxy
}

func (p *ProductCategories) CollectionName() string {
	return "product_categories"
}

func (p *ProductCategories) Name() string {
	return p.GetString("name")
}

func (p *ProductCategories) SetName(name string) {
	p.Set("name", name)
}

func (p *ProductCategories) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *ProductCategories) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *ProductCategories) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *ProductCategories) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *ProductCategories) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *ProductCategories) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}
