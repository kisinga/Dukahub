// Autogenerated by github.com/snonky/pocketbase-gogen. Do not edit.
package models

import (
	"github.com/pocketbase/pocketbase/core"
	"github.com/pocketbase/pocketbase/tools/types"
)

type Users struct {
	core.BaseRecordProxy
}

func (p *Users) CollectionName() string {
	return "users"
}

func (p *Users) Username() string {
	return p.GetString("username")
}

func (p *Users) SetUsername(username string) {
	p.Set("username", username)
}

func (p *Users) Name() string {
	return p.GetString("name")
}

func (p *Users) SetName(name string) {
	p.Set("name", name)
}

func (p *Users) Avatar() string {
	return p.GetString("avatar")
}

func (p *Users) SetAvatar(avatar string) {
	p.Set("avatar", avatar)
}

func (p *Users) Company() []*Companies {
	rels := p.ExpandedAll("company")
	proxies := make([]*Companies, len(rels))
	for i := range len(rels) {
		proxies[i] = &Companies{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Users) SetCompany(company []*Companies) {
	records := make([]*core.Record, len(company))
	ids := make([]string, len(company))
	for i, r := range company {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("company", ids)
	e := p.Expand()
	e["company"] = records
	p.SetExpand(e)
}

func (p *Users) DefaultCompany() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("defaultCompany"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Users) SetDefaultCompany(defaultCompany *Companies) {
	var id string
	if defaultCompany != nil {
		id = defaultCompany.Id
	}
	p.Record.Set("defaultCompany", id)
	e := p.Expand()
	if defaultCompany != nil {
		e["defaultCompany"] = defaultCompany.Record
	} else {
		delete(e, "defaultCompany")
	}
	p.SetExpand(e)
}

func (p *Users) Level() float64 {
	return p.GetFloat("level")
}

func (p *Users) SetLevel(level float64) {
	p.Set("level", level)
}

func (p *Users) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Users) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Users) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Users) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

func (p *Users) DeletedAt() types.DateTime {
	return p.GetDateTime("deleted_at")
}

func (p *Users) SetDeletedAt(deletedAt types.DateTime) {
	p.Set("deleted_at", deletedAt)
}

type DailyStockTakes struct {
	core.BaseRecordProxy
}

func (p *DailyStockTakes) CollectionName() string {
	return "daily_stock_takes"
}

func (p *DailyStockTakes) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyStockTakes) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *DailyStockTakes) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyStockTakes) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *DailyStockTakes) User() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyStockTakes) SetUser(user *Users) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *DailyStockTakes) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *DailyStockTakes) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *DailyStockTakes) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyStockTakes) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *DailyStockTakes) OpeningBal() float64 {
	return p.GetFloat("opening_bal")
}

func (p *DailyStockTakes) SetOpeningBal(openingBal float64) {
	p.Set("opening_bal", openingBal)
}

func (p *DailyStockTakes) ClosingBal() float64 {
	return p.GetFloat("closing_bal")
}

func (p *DailyStockTakes) SetClosingBal(closingBal float64) {
	p.Set("closing_bal", closingBal)
}

func (p *DailyStockTakes) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *DailyStockTakes) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *DailyStockTakes) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *DailyStockTakes) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type DailyAccounts struct {
	core.BaseRecordProxy
}

func (p *DailyAccounts) CollectionName() string {
	return "daily_accounts"
}

func (p *DailyAccounts) OpeningBal() int {
	return p.GetInt("opening_bal")
}

func (p *DailyAccounts) SetOpeningBal(openingBal int) {
	p.Set("opening_bal", openingBal)
}

func (p *DailyAccounts) ClosingBal() int {
	return p.GetInt("closing_bal")
}

func (p *DailyAccounts) SetClosingBal(closingBal int) {
	p.Set("closing_bal", closingBal)
}

func (p *DailyAccounts) Account() *CompanyAccounts {
	var proxy *CompanyAccounts
	if rel := p.ExpandedOne("account"); rel != nil {
		proxy = &CompanyAccounts{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyAccounts) SetAccount(account *CompanyAccounts) {
	var id string
	if account != nil {
		id = account.Id
	}
	p.Record.Set("account", id)
	e := p.Expand()
	if account != nil {
		e["account"] = account.Record
	} else {
		delete(e, "account")
	}
	p.SetExpand(e)
}

func (p *DailyAccounts) Notes() string {
	return p.GetString("notes")
}

func (p *DailyAccounts) SetNotes(notes string) {
	p.Set("notes", notes)
}

func (p *DailyAccounts) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyAccounts) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *DailyAccounts) User() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailyAccounts) SetUser(user *Users) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *DailyAccounts) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *DailyAccounts) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *DailyAccounts) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *DailyAccounts) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *DailyAccounts) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *DailyAccounts) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

func (p *DailyAccounts) TotalDeposits() float64 {
	return p.GetFloat("total_deposits")
}

func (p *DailyAccounts) SetTotalDeposits(totalDeposits float64) {
	p.Set("total_deposits", totalDeposits)
}

func (p *DailyAccounts) TotalWithdrawals() float64 {
	return p.GetFloat("total_withdrawals")
}

func (p *DailyAccounts) SetTotalWithdrawals(totalWithdrawals float64) {
	p.Set("total_withdrawals", totalWithdrawals)
}

func (p *DailyAccounts) DeletedAt() types.DateTime {
	return p.GetDateTime("deleted_at")
}

func (p *DailyAccounts) SetDeletedAt(deletedAt types.DateTime) {
	p.Set("deleted_at", deletedAt)
}

type AccountTypes struct {
	core.BaseRecordProxy
}

func (p *AccountTypes) CollectionName() string {
	return "account_types"
}

func (p *AccountTypes) Name() string {
	return p.GetString("name")
}

func (p *AccountTypes) SetName(name string) {
	p.Set("name", name)
}

func (p *AccountTypes) Icons() []string {
	return p.GetStringSlice("icons")
}

func (p *AccountTypes) SetIcons(icons []string) {
	p.Set("icons", icons)
}

func (p *AccountTypes) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *AccountTypes) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *AccountTypes) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *AccountTypes) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Skus struct {
	core.BaseRecordProxy
}

func (p *Skus) CollectionName() string {
	return "skus"
}

func (p *Skus) Name() string {
	return p.GetString("name")
}

func (p *Skus) SetName(name string) {
	p.Set("name", name)
}

func (p *Skus) Initials() string {
	return p.GetString("initials")
}

func (p *Skus) SetInitials(initials string) {
	p.Set("initials", initials)
}

func (p *Skus) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Skus) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Skus) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Skus) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Products struct {
	core.BaseRecordProxy
}

func (p *Products) CollectionName() string {
	return "products"
}

func (p *Products) Name() string {
	return p.GetString("name")
}

func (p *Products) SetName(name string) {
	p.Set("name", name)
}

func (p *Products) Skus() []*Skus {
	rels := p.ExpandedAll("skus")
	proxies := make([]*Skus, len(rels))
	for i := range len(rels) {
		proxies[i] = &Skus{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Products) SetSkus(skus []*Skus) {
	records := make([]*core.Record, len(skus))
	ids := make([]string, len(skus))
	for i, r := range skus {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("skus", ids)
	e := p.Expand()
	e["skus"] = records
	p.SetExpand(e)
}

func (p *Products) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Products) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Products) Photos() []string {
	return p.GetStringSlice("photos")
}

func (p *Products) SetPhotos(photos []string) {
	p.Set("photos", photos)
}

func (p *Products) Category() []*ProductCategories {
	rels := p.ExpandedAll("category")
	proxies := make([]*ProductCategories, len(rels))
	for i := range len(rels) {
		proxies[i] = &ProductCategories{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Products) SetCategory(category []*ProductCategories) {
	records := make([]*core.Record, len(category))
	ids := make([]string, len(category))
	for i, r := range category {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("category", ids)
	e := p.Expand()
	e["category"] = records
	p.SetExpand(e)
}

func (p *Products) Barcode() string {
	return p.GetString("barcode")
}

func (p *Products) SetBarcode(barcode string) {
	p.Set("barcode", barcode)
}

func (p *Products) TaxRate() float64 {
	return p.GetFloat("taxRate")
}

func (p *Products) SetTaxRate(taxRate float64) {
	p.Set("taxRate", taxRate)
}

func (p *Products) Inventory() *Inventory {
	var proxy *Inventory
	if rel := p.ExpandedOne("inventory"); rel != nil {
		proxy = &Inventory{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Products) SetInventory(inventory *Inventory) {
	var id string
	if inventory != nil {
		id = inventory.Id
	}
	p.Record.Set("inventory", id)
	e := p.Expand()
	if inventory != nil {
		e["inventory"] = inventory.Record
	} else {
		delete(e, "inventory")
	}
	p.SetExpand(e)
}

func (p *Products) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Products) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Products) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Products) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Partners struct {
	core.BaseRecordProxy
}

func (p *Partners) CollectionName() string {
	return "partners"
}

func (p *Partners) Name() string {
	return p.GetString("name")
}

func (p *Partners) SetName(name string) {
	p.Set("name", name)
}

func (p *Partners) Phone() string {
	return p.GetString("phone")
}

func (p *Partners) SetPhone(phone string) {
	p.Set("phone", phone)
}

func (p *Partners) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Partners) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Partners) Balance() float64 {
	return p.GetFloat("balance")
}

func (p *Partners) SetBalance(balance float64) {
	p.Set("balance", balance)
}

func (p *Partners) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Partners) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Partners) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Partners) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type StatusSelectType int

const (
	Paid StatusSelectType = iota
	Partial
	Pending
)

var zzStatusSelectTypeSelectNameMap = map[string]StatusSelectType{
	"paid":    0,
	"partial": 1,
	"pending": 2,
}
var zzStatusSelectTypeSelectIotaMap = map[StatusSelectType]string{
	0: "paid",
	1: "partial",
	2: "pending",
}

type TypeSelectType int

const (
	Sale TypeSelectType = iota
	Purchase
)

var zzTypeSelectTypeSelectNameMap = map[string]TypeSelectType{
	"sale":     0,
	"purchase": 1,
}
var zzTypeSelectTypeSelectIotaMap = map[TypeSelectType]string{
	0: "sale",
	1: "purchase",
}

type Invoices struct {
	core.BaseRecordProxy
}

func (p *Invoices) CollectionName() string {
	return "invoices"
}

func (p *Invoices) Partner() *Partners {
	var proxy *Partners
	if rel := p.ExpandedOne("partner"); rel != nil {
		proxy = &Partners{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Invoices) SetPartner(partner *Partners) {
	var id string
	if partner != nil {
		id = partner.Id
	}
	p.Record.Set("partner", id)
	e := p.Expand()
	if partner != nil {
		e["partner"] = partner.Record
	} else {
		delete(e, "partner")
	}
	p.SetExpand(e)
}

func (p *Invoices) Amount() float64 {
	return p.GetFloat("amount")
}

func (p *Invoices) SetAmount(amount float64) {
	p.Set("amount", amount)
}

func (p *Invoices) Status() StatusSelectType {
	option := p.GetString("status")
	i, ok := zzStatusSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Invoices) SetStatus(status StatusSelectType) {
	i, ok := zzStatusSelectTypeSelectIotaMap[status]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("status", i)
}

func (p *Invoices) Bal() float64 {
	return p.GetFloat("bal")
}

func (p *Invoices) SetBal(bal float64) {
	p.Set("bal", bal)
}

func (p *Invoices) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Invoices) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Invoices) User() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Invoices) SetUser(user *Users) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *Invoices) Type() TypeSelectType {
	option := p.GetString("type")
	i, ok := zzTypeSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Invoices) SetType(type_ TypeSelectType) {
	i, ok := zzTypeSelectTypeSelectIotaMap[type_]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("type", i)
}

func (p *Invoices) Transactions() []*Transactions {
	rels := p.ExpandedAll("transactions")
	proxies := make([]*Transactions, len(rels))
	for i := range len(rels) {
		proxies[i] = &Transactions{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *Invoices) SetTransactions(transactions []*Transactions) {
	records := make([]*core.Record, len(transactions))
	ids := make([]string, len(transactions))
	for i, r := range transactions {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("transactions", ids)
	e := p.Expand()
	e["transactions"] = records
	p.SetExpand(e)
}

func (p *Invoices) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *Invoices) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *Invoices) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Invoices) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Invoices) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Invoices) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Purchases struct {
	core.BaseRecordProxy
}

func (p *Purchases) CollectionName() string {
	return "purchases"
}

func (p *Purchases) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *Purchases) Quantity() float64 {
	return p.GetFloat("quantity")
}

func (p *Purchases) SetQuantity(quantity float64) {
	p.Set("quantity", quantity)
}

func (p *Purchases) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *Purchases) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Purchases) User() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetUser(user *Users) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *Purchases) Invoice() *Invoices {
	var proxy *Invoices
	if rel := p.ExpandedOne("invoice"); rel != nil {
		proxy = &Invoices{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetInvoice(invoice *Invoices) {
	var id string
	if invoice != nil {
		id = invoice.Id
	}
	p.Record.Set("invoice", id)
	e := p.Expand()
	if invoice != nil {
		e["invoice"] = invoice.Record
	} else {
		delete(e, "invoice")
	}
	p.SetExpand(e)
}

func (p *Purchases) Transaction() *Transactions {
	var proxy *Transactions
	if rel := p.ExpandedOne("transaction"); rel != nil {
		proxy = &Transactions{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Purchases) SetTransaction(transaction *Transactions) {
	var id string
	if transaction != nil {
		id = transaction.Id
	}
	p.Record.Set("transaction", id)
	e := p.Expand()
	if transaction != nil {
		e["transaction"] = transaction.Record
	} else {
		delete(e, "transaction")
	}
	p.SetExpand(e)
}

func (p *Purchases) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *Purchases) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *Purchases) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Purchases) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Purchases) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Purchases) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type CompanyTypeSelectType int

const (
	Headquaters CompanyTypeSelectType = iota
	Branch
	Store
)

var zzCompanyTypeSelectTypeSelectNameMap = map[string]CompanyTypeSelectType{
	"headquaters": 0,
	"branch":      1,
	"store":       2,
}
var zzCompanyTypeSelectTypeSelectIotaMap = map[CompanyTypeSelectType]string{
	0: "headquaters",
	1: "branch",
	2: "store",
}

type Companies struct {
	core.BaseRecordProxy
}

func (p *Companies) CollectionName() string {
	return "companies"
}

func (p *Companies) Logo() string {
	return p.GetString("logo")
}

func (p *Companies) SetLogo(logo string) {
	p.Set("logo", logo)
}

func (p *Companies) Location() string {
	return p.GetString("location")
}

func (p *Companies) SetLocation(location string) {
	p.Set("location", location)
}

func (p *Companies) Name() string {
	return p.GetString("name")
}

func (p *Companies) SetName(name string) {
	p.Set("name", name)
}

func (p *Companies) Phone() string {
	return p.GetString("phone")
}

func (p *Companies) SetPhone(phone string) {
	p.Set("phone", phone)
}

func (p *Companies) AdminConfig() string {
	return p.GetString("admin_config")
}

func (p *Companies) SetAdminConfig(adminConfig string) {
	p.Set("admin_config", adminConfig)
}

func (p *Companies) ParentCompany() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("parent_company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Companies) SetParentCompany(parentCompany *Companies) {
	var id string
	if parentCompany != nil {
		id = parentCompany.Id
	}
	p.Record.Set("parent_company", id)
	e := p.Expand()
	if parentCompany != nil {
		e["parent_company"] = parentCompany.Record
	} else {
		delete(e, "parent_company")
	}
	p.SetExpand(e)
}

func (p *Companies) CompanyType() CompanyTypeSelectType {
	option := p.GetString("company_type")
	i, ok := zzCompanyTypeSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Companies) SetCompanyType(companyType CompanyTypeSelectType) {
	i, ok := zzCompanyTypeSelectTypeSelectIotaMap[companyType]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("company_type", i)
}

func (p *Companies) Address() string {
	return p.GetString("address")
}

func (p *Companies) SetAddress(address string) {
	p.Set("address", address)
}

func (p *Companies) ContactPersonName() string {
	return p.GetString("contact_person_name")
}

func (p *Companies) SetContactPersonName(contactPersonName string) {
	p.Set("contact_person_name", contactPersonName)
}

func (p *Companies) ContactPersonEmail() string {
	return p.GetString("contact_person_email")
}

func (p *Companies) SetContactPersonEmail(contactPersonEmail string) {
	p.Set("contact_person_email", contactPersonEmail)
}

func (p *Companies) TaxId() string {
	return p.GetString("tax_id")
}

func (p *Companies) SetTaxId(taxId string) {
	p.Set("tax_id", taxId)
}

func (p *Companies) Industry() string {
	return p.GetString("industry")
}

func (p *Companies) SetIndustry(industry string) {
	p.Set("industry", industry)
}

func (p *Companies) DeletedAt() types.DateTime {
	return p.GetDateTime("deleted_at")
}

func (p *Companies) SetDeletedAt(deletedAt types.DateTime) {
	p.Set("deleted_at", deletedAt)
}

func (p *Companies) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Companies) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Companies) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Companies) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type CompanyAccounts struct {
	core.BaseRecordProxy
}

func (p *CompanyAccounts) CollectionName() string {
	return "company_accounts"
}

func (p *CompanyAccounts) AccountNumber() string {
	return p.GetString("account_number")
}

func (p *CompanyAccounts) SetAccountNumber(accountNumber string) {
	p.Set("account_number", accountNumber)
}

func (p *CompanyAccounts) Name() string {
	return p.GetString("name")
}

func (p *CompanyAccounts) SetName(name string) {
	p.Set("name", name)
}

func (p *CompanyAccounts) Type() *AccountTypes {
	var proxy *AccountTypes
	if rel := p.ExpandedOne("type"); rel != nil {
		proxy = &AccountTypes{}
		proxy.Record = rel
	}
	return proxy
}

func (p *CompanyAccounts) SetType(type_ *AccountTypes) {
	var id string
	if type_ != nil {
		id = type_.Id
	}
	p.Record.Set("type", id)
	e := p.Expand()
	if type_ != nil {
		e["type"] = type_.Record
	} else {
		delete(e, "type")
	}
	p.SetExpand(e)
}

func (p *CompanyAccounts) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *CompanyAccounts) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *CompanyAccounts) Bal() float64 {
	return p.GetFloat("bal")
}

func (p *CompanyAccounts) SetBal(bal float64) {
	p.Set("bal", bal)
}

func (p *CompanyAccounts) IconId() int {
	return p.GetInt("icon_id")
}

func (p *CompanyAccounts) SetIconId(iconId int) {
	p.Set("icon_id", iconId)
}

func (p *CompanyAccounts) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *CompanyAccounts) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *CompanyAccounts) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *CompanyAccounts) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

func (p *CompanyAccounts) TotalRevenue() float64 {
	return p.GetFloat("total_revenue")
}

func (p *CompanyAccounts) SetTotalRevenue(totalRevenue float64) {
	p.Set("total_revenue", totalRevenue)
}

func (p *CompanyAccounts) TotalExpenses() float64 {
	return p.GetFloat("total_expenses")
}

func (p *CompanyAccounts) SetTotalExpenses(totalExpenses float64) {
	p.Set("total_expenses", totalExpenses)
}

func (p *CompanyAccounts) NetProfit() float64 {
	return p.GetFloat("net_profit")
}

func (p *CompanyAccounts) SetNetProfit(netProfit float64) {
	p.Set("net_profit", netProfit)
}

func (p *CompanyAccounts) DeletedAt() types.DateTime {
	return p.GetDateTime("deleted_at")
}

func (p *CompanyAccounts) SetDeletedAt(deletedAt types.DateTime) {
	p.Set("deleted_at", deletedAt)
}

type TypeSelectType2 int

const (
	Debit TypeSelectType2 = iota
	Credit
)

var zzTypeSelectType2SelectNameMap = map[string]TypeSelectType2{
	"debit":  0,
	"credit": 1,
}
var zzTypeSelectType2SelectIotaMap = map[TypeSelectType2]string{
	0: "debit",
	1: "credit",
}

type ReferenceTypeSelectType int

const (
	Sale2 ReferenceTypeSelectType = iota
	Purchase2
	Expense
	Adjustment
)

var zzReferenceTypeSelectTypeSelectNameMap = map[string]ReferenceTypeSelectType{
	"sale":       0,
	"purchase":   1,
	"expense":    2,
	"adjustment": 3,
}
var zzReferenceTypeSelectTypeSelectIotaMap = map[ReferenceTypeSelectType]string{
	0: "sale",
	1: "purchase",
	2: "expense",
	3: "adjustment",
}

type Transactions struct {
	core.BaseRecordProxy
}

func (p *Transactions) CollectionName() string {
	return "transactions"
}

func (p *Transactions) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Transactions) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Transactions) Account() *CompanyAccounts {
	var proxy *CompanyAccounts
	if rel := p.ExpandedOne("account"); rel != nil {
		proxy = &CompanyAccounts{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Transactions) SetAccount(account *CompanyAccounts) {
	var id string
	if account != nil {
		id = account.Id
	}
	p.Record.Set("account", id)
	e := p.Expand()
	if account != nil {
		e["account"] = account.Record
	} else {
		delete(e, "account")
	}
	p.SetExpand(e)
}

func (p *Transactions) Type() TypeSelectType2 {
	option := p.GetString("type")
	i, ok := zzTypeSelectType2SelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Transactions) SetType(type_ TypeSelectType2) {
	i, ok := zzTypeSelectType2SelectIotaMap[type_]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("type", i)
}

func (p *Transactions) Amount() float64 {
	return p.GetFloat("amount")
}

func (p *Transactions) SetAmount(amount float64) {
	p.Set("amount", amount)
}

func (p *Transactions) TransactionId() string {
	return p.GetString("transaction_id")
}

func (p *Transactions) SetTransactionId(transactionId string) {
	p.Set("transaction_id", transactionId)
}

func (p *Transactions) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *Transactions) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *Transactions) Author() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("author"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Transactions) SetAuthor(author *Users) {
	var id string
	if author != nil {
		id = author.Id
	}
	p.Record.Set("author", id)
	e := p.Expand()
	if author != nil {
		e["author"] = author.Record
	} else {
		delete(e, "author")
	}
	p.SetExpand(e)
}

func (p *Transactions) ReferenceType() ReferenceTypeSelectType {
	option := p.GetString("reference_type")
	i, ok := zzReferenceTypeSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *Transactions) SetReferenceType(referenceType ReferenceTypeSelectType) {
	i, ok := zzReferenceTypeSelectTypeSelectIotaMap[referenceType]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("reference_type", i)
}

func (p *Transactions) ReferenceId() string {
	return p.GetString("reference_id")
}

func (p *Transactions) SetReferenceId(referenceId string) {
	p.Set("reference_id", referenceId)
}

func (p *Transactions) TaxRate() float64 {
	return p.GetFloat("tax_rate")
}

func (p *Transactions) SetTaxRate(taxRate float64) {
	p.Set("tax_rate", taxRate)
}

func (p *Transactions) TaxAmount() float64 {
	return p.GetFloat("tax_amount")
}

func (p *Transactions) SetTaxAmount(taxAmount float64) {
	p.Set("tax_amount", taxAmount)
}

func (p *Transactions) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Transactions) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Transactions) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Transactions) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type SalesDetails struct {
	core.BaseRecordProxy
}

func (p *SalesDetails) CollectionName() string {
	return "sales_details"
}

func (p *SalesDetails) Quantity() float64 {
	return p.GetFloat("quantity")
}

func (p *SalesDetails) SetQuantity(quantity float64) {
	p.Set("quantity", quantity)
}

func (p *SalesDetails) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *SalesDetails) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *SalesDetails) UnitPrice() float64 {
	return p.GetFloat("unit_price")
}

func (p *SalesDetails) SetUnitPrice(unitPrice float64) {
	p.Set("unit_price", unitPrice)
}

func (p *SalesDetails) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *SalesDetails) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *SalesDetails) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *SalesDetails) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *SalesDetails) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *SalesDetails) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Expenses struct {
	core.BaseRecordProxy
}

func (p *Expenses) CollectionName() string {
	return "expenses"
}

func (p *Expenses) Amount() float64 {
	return p.GetFloat("amount")
}

func (p *Expenses) SetAmount(amount float64) {
	p.Set("amount", amount)
}

func (p *Expenses) Purpose() string {
	return p.GetString("purpose")
}

func (p *Expenses) SetPurpose(purpose string) {
	p.Set("purpose", purpose)
}

func (p *Expenses) Transaction() *Transactions {
	var proxy *Transactions
	if rel := p.ExpandedOne("transaction"); rel != nil {
		proxy = &Transactions{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Expenses) SetTransaction(transaction *Transactions) {
	var id string
	if transaction != nil {
		id = transaction.Id
	}
	p.Record.Set("transaction", id)
	e := p.Expand()
	if transaction != nil {
		e["transaction"] = transaction.Record
	} else {
		delete(e, "transaction")
	}
	p.SetExpand(e)
}

func (p *Expenses) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Expenses) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Expenses) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Expenses) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Expenses) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Expenses) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type StatusSelectType2 int

const (
	Open StatusSelectType2 = iota
	Closed
)

var zzStatusSelectType2SelectNameMap = map[string]StatusSelectType2{
	"open":   0,
	"closed": 1,
}
var zzStatusSelectType2SelectIotaMap = map[StatusSelectType2]string{
	0: "open",
	1: "closed",
}

type OpenCloseDetails struct {
	core.BaseRecordProxy
}

func (p *OpenCloseDetails) CollectionName() string {
	return "open_close_details"
}

func (p *OpenCloseDetails) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *OpenCloseDetails) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *OpenCloseDetails) Status() StatusSelectType2 {
	option := p.GetString("status")
	i, ok := zzStatusSelectType2SelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *OpenCloseDetails) SetStatus(status StatusSelectType2) {
	i, ok := zzStatusSelectType2SelectIotaMap[status]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("status", i)
}

func (p *OpenCloseDetails) OpenTime() types.DateTime {
	return p.GetDateTime("open_time")
}

func (p *OpenCloseDetails) SetOpenTime(openTime types.DateTime) {
	p.Set("open_time", openTime)
}

func (p *OpenCloseDetails) CloseTime() types.DateTime {
	return p.GetDateTime("close_time")
}

func (p *OpenCloseDetails) SetCloseTime(closeTime types.DateTime) {
	p.Set("close_time", closeTime)
}

func (p *OpenCloseDetails) User() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *OpenCloseDetails) SetUser(user *Users) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *OpenCloseDetails) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *OpenCloseDetails) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *OpenCloseDetails) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *OpenCloseDetails) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Models struct {
	core.BaseRecordProxy
}

func (p *Models) CollectionName() string {
	return "models"
}

func (p *Models) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Models) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Models) Metadata() string {
	return p.GetString("metadata")
}

func (p *Models) SetMetadata(metadata string) {
	p.Set("metadata", metadata)
}

func (p *Models) Model() string {
	return p.GetString("model")
}

func (p *Models) SetModel(model string) {
	p.Set("model", model)
}

func (p *Models) Weights() string {
	return p.GetString("weights")
}

func (p *Models) SetWeights(weights string) {
	p.Set("weights", weights)
}

func (p *Models) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Models) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Models) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Models) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type ProductCategories struct {
	core.BaseRecordProxy
}

func (p *ProductCategories) CollectionName() string {
	return "product_categories"
}

func (p *ProductCategories) Name() string {
	return p.GetString("name")
}

func (p *ProductCategories) SetName(name string) {
	p.Set("name", name)
}

func (p *ProductCategories) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *ProductCategories) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *ProductCategories) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *ProductCategories) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *ProductCategories) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *ProductCategories) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type PaymentStatusSelectType int

const (
	Paid2 PaymentStatusSelectType = iota
	Partial2
	Pending2
)

var zzPaymentStatusSelectTypeSelectNameMap = map[string]PaymentStatusSelectType{
	"paid":    0,
	"partial": 1,
	"pending": 2,
}
var zzPaymentStatusSelectTypeSelectIotaMap = map[PaymentStatusSelectType]string{
	0: "paid",
	1: "partial",
	2: "pending",
}

type TransactionTypeSelectType int

const (
	Sale3 TransactionTypeSelectType = iota
	Return
	Exchange
)

var zzTransactionTypeSelectTypeSelectNameMap = map[string]TransactionTypeSelectType{
	"sale":     0,
	"return":   1,
	"exchange": 2,
}
var zzTransactionTypeSelectTypeSelectIotaMap = map[TransactionTypeSelectType]string{
	0: "sale",
	1: "return",
	2: "exchange",
}

type PaymentMethodSelectType int

const (
	Cash PaymentMethodSelectType = iota
	Card
	MobileMoney
	BankTransfer
)

var zzPaymentMethodSelectTypeSelectNameMap = map[string]PaymentMethodSelectType{
	"cash":          0,
	"card":          1,
	"mobile_money":  2,
	"bank_transfer": 3,
}
var zzPaymentMethodSelectTypeSelectIotaMap = map[PaymentMethodSelectType]string{
	0: "cash",
	1: "card",
	2: "mobile_money",
	3: "bank_transfer",
}

type SalesTransactions struct {
	core.BaseRecordProxy
}

func (p *SalesTransactions) CollectionName() string {
	return "sales_transactions"
}

func (p *SalesTransactions) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *SalesTransactions) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *SalesTransactions) Salesperson() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("salesperson"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *SalesTransactions) SetSalesperson(salesperson *Users) {
	var id string
	if salesperson != nil {
		id = salesperson.Id
	}
	p.Record.Set("salesperson", id)
	e := p.Expand()
	if salesperson != nil {
		e["salesperson"] = salesperson.Record
	} else {
		delete(e, "salesperson")
	}
	p.SetExpand(e)
}

func (p *SalesTransactions) TotalAmount() float64 {
	return p.GetFloat("total_amount")
}

func (p *SalesTransactions) SetTotalAmount(totalAmount float64) {
	p.Set("total_amount", totalAmount)
}

func (p *SalesTransactions) PaymentStatus() PaymentStatusSelectType {
	option := p.GetString("payment_status")
	i, ok := zzPaymentStatusSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *SalesTransactions) SetPaymentStatus(paymentStatus PaymentStatusSelectType) {
	i, ok := zzPaymentStatusSelectTypeSelectIotaMap[paymentStatus]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("payment_status", i)
}

func (p *SalesTransactions) RemainingBalance() float64 {
	return p.GetFloat("remaining_balance")
}

func (p *SalesTransactions) SetRemainingBalance(remainingBalance float64) {
	p.Set("remaining_balance", remainingBalance)
}

func (p *SalesTransactions) Customer() *Partners {
	var proxy *Partners
	if rel := p.ExpandedOne("customer"); rel != nil {
		proxy = &Partners{}
		proxy.Record = rel
	}
	return proxy
}

func (p *SalesTransactions) SetCustomer(customer *Partners) {
	var id string
	if customer != nil {
		id = customer.Id
	}
	p.Record.Set("customer", id)
	e := p.Expand()
	if customer != nil {
		e["customer"] = customer.Record
	} else {
		delete(e, "customer")
	}
	p.SetExpand(e)
}

func (p *SalesTransactions) TransactionType() TransactionTypeSelectType {
	option := p.GetString("transaction_type")
	i, ok := zzTransactionTypeSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *SalesTransactions) SetTransactionType(transactionType TransactionTypeSelectType) {
	i, ok := zzTransactionTypeSelectTypeSelectIotaMap[transactionType]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("transaction_type", i)
}

func (p *SalesTransactions) Notes() string {
	return p.GetString("notes")
}

func (p *SalesTransactions) SetNotes(notes string) {
	p.Set("notes", notes)
}

func (p *SalesTransactions) TransactionDate() types.DateTime {
	return p.GetDateTime("transaction_date")
}

func (p *SalesTransactions) SetTransactionDate(transactionDate types.DateTime) {
	p.Set("transaction_date", transactionDate)
}

func (p *SalesTransactions) SalesDetails() []*SalesDetails {
	rels := p.ExpandedAll("sales_details")
	proxies := make([]*SalesDetails, len(rels))
	for i := range len(rels) {
		proxies[i] = &SalesDetails{}
		proxies[i].Record = rels[i]
	}
	return proxies
}

func (p *SalesTransactions) SetSalesDetails(salesDetails []*SalesDetails) {
	records := make([]*core.Record, len(salesDetails))
	ids := make([]string, len(salesDetails))
	for i, r := range salesDetails {
		records[i] = r.Record
		ids[i] = r.Record.Id
	}
	p.Record.Set("sales_details", ids)
	e := p.Expand()
	e["sales_details"] = records
	p.SetExpand(e)
}

func (p *SalesTransactions) Transaction() *Transactions {
	var proxy *Transactions
	if rel := p.ExpandedOne("transaction"); rel != nil {
		proxy = &Transactions{}
		proxy.Record = rel
	}
	return proxy
}

func (p *SalesTransactions) SetTransaction(transaction *Transactions) {
	var id string
	if transaction != nil {
		id = transaction.Id
	}
	p.Record.Set("transaction", id)
	e := p.Expand()
	if transaction != nil {
		e["transaction"] = transaction.Record
	} else {
		delete(e, "transaction")
	}
	p.SetExpand(e)
}

func (p *SalesTransactions) NetProfit() float64 {
	return p.GetFloat("net_profit")
}

func (p *SalesTransactions) SetNetProfit(netProfit float64) {
	p.Set("net_profit", netProfit)
}

func (p *SalesTransactions) TaxAmount() float64 {
	return p.GetFloat("tax_amount")
}

func (p *SalesTransactions) SetTaxAmount(taxAmount float64) {
	p.Set("tax_amount", taxAmount)
}

func (p *SalesTransactions) DiscountAmount() float64 {
	return p.GetFloat("discount_amount")
}

func (p *SalesTransactions) SetDiscountAmount(discountAmount float64) {
	p.Set("discount_amount", discountAmount)
}

func (p *SalesTransactions) PaymentMethod() PaymentMethodSelectType {
	option := p.GetString("payment_method")
	i, ok := zzPaymentMethodSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *SalesTransactions) SetPaymentMethod(paymentMethod PaymentMethodSelectType) {
	i, ok := zzPaymentMethodSelectTypeSelectIotaMap[paymentMethod]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("payment_method", i)
}

func (p *SalesTransactions) ShippingAddress() string {
	return p.GetString("shipping_address")
}

func (p *SalesTransactions) SetShippingAddress(shippingAddress string) {
	p.Set("shipping_address", shippingAddress)
}

func (p *SalesTransactions) DeletedAt() types.DateTime {
	return p.GetDateTime("deleted_at")
}

func (p *SalesTransactions) SetDeletedAt(deletedAt types.DateTime) {
	p.Set("deleted_at", deletedAt)
}

func (p *SalesTransactions) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *SalesTransactions) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *SalesTransactions) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *SalesTransactions) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Admins struct {
	core.BaseRecordProxy
}

func (p *Admins) CollectionName() string {
	return "admins"
}

func (p *Admins) Avatar() string {
	return p.GetString("avatar")
}

func (p *Admins) SetAvatar(avatar string) {
	p.Set("avatar", avatar)
}

func (p *Admins) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Admins) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Admins) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Admins) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type TypeSelectType3 int

const Train TypeSelectType3 = iota

var zzTypeSelectType3SelectNameMap = map[string]TypeSelectType3{"train": 0}
var zzTypeSelectType3SelectIotaMap = map[TypeSelectType3]string{0: "train"}

type JobQueue struct {
	core.BaseRecordProxy
}

func (p *JobQueue) CollectionName() string {
	return "job_queue"
}

func (p *JobQueue) Name() string {
	return p.GetString("name")
}

func (p *JobQueue) SetName(name string) {
	p.Set("name", name)
}

func (p *JobQueue) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *JobQueue) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *JobQueue) User() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *JobQueue) SetUser(user *Users) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *JobQueue) Type() TypeSelectType3 {
	option := p.GetString("type")
	i, ok := zzTypeSelectType3SelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *JobQueue) SetType(type_ TypeSelectType3) {
	i, ok := zzTypeSelectType3SelectIotaMap[type_]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("type", i)
}

func (p *JobQueue) Status() float64 {
	return p.GetFloat("status")
}

func (p *JobQueue) SetStatus(status float64) {
	p.Set("status", status)
}

func (p *JobQueue) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *JobQueue) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *JobQueue) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *JobQueue) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type DailySummaries struct {
	core.BaseRecordProxy
}

func (p *DailySummaries) CollectionName() string {
	return "daily_summaries"
}

func (p *DailySummaries) Date() types.DateTime {
	return p.GetDateTime("date")
}

func (p *DailySummaries) SetDate(date types.DateTime) {
	p.Set("date", date)
}

func (p *DailySummaries) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *DailySummaries) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *DailySummaries) TotalSales() float64 {
	return p.GetFloat("total_sales")
}

func (p *DailySummaries) SetTotalSales(totalSales float64) {
	p.Set("total_sales", totalSales)
}

func (p *DailySummaries) TotalPurchases() float64 {
	return p.GetFloat("total_purchases")
}

func (p *DailySummaries) SetTotalPurchases(totalPurchases float64) {
	p.Set("total_purchases", totalPurchases)
}

func (p *DailySummaries) TotalExpenses() float64 {
	return p.GetFloat("total_expenses")
}

func (p *DailySummaries) SetTotalExpenses(totalExpenses float64) {
	p.Set("total_expenses", totalExpenses)
}

func (p *DailySummaries) TopSellingProducts() string {
	return p.GetString("top_selling_products")
}

func (p *DailySummaries) SetTopSellingProducts(topSellingProducts string) {
	p.Set("top_selling_products", topSellingProducts)
}

func (p *DailySummaries) ProfitMargin() float64 {
	return p.GetFloat("profit_margin")
}

func (p *DailySummaries) SetProfitMargin(profitMargin float64) {
	p.Set("profit_margin", profitMargin)
}

func (p *DailySummaries) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *DailySummaries) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *DailySummaries) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *DailySummaries) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type Inventory struct {
	core.BaseRecordProxy
}

func (p *Inventory) CollectionName() string {
	return "inventory"
}

func (p *Inventory) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Inventory) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *Inventory) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Inventory) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *Inventory) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *Inventory) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *Inventory) CurrentQuantity() float64 {
	return p.GetFloat("current_quantity")
}

func (p *Inventory) SetCurrentQuantity(currentQuantity float64) {
	p.Set("current_quantity", currentQuantity)
}

func (p *Inventory) ReorderPoint() float64 {
	return p.GetFloat("reorder_point")
}

func (p *Inventory) SetReorderPoint(reorderPoint float64) {
	p.Set("reorder_point", reorderPoint)
}

func (p *Inventory) CostPrice() float64 {
	return p.GetFloat("cost_price")
}

func (p *Inventory) SetCostPrice(costPrice float64) {
	p.Set("cost_price", costPrice)
}

func (p *Inventory) RetailPrice() float64 {
	return p.GetFloat("retail_price")
}

func (p *Inventory) SetRetailPrice(retailPrice float64) {
	p.Set("retail_price", retailPrice)
}

func (p *Inventory) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *Inventory) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *Inventory) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *Inventory) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type ReasonCodeSelectType int

const (
	Sale4 ReasonCodeSelectType = iota
	Purchase3
	Return2
	Adjustment2
	Loss
	Damage
)

var zzReasonCodeSelectTypeSelectNameMap = map[string]ReasonCodeSelectType{
	"sale":       0,
	"purchase":   1,
	"return":     2,
	"adjustment": 3,
	"loss":       4,
	"damage":     5,
}
var zzReasonCodeSelectTypeSelectIotaMap = map[ReasonCodeSelectType]string{
	0: "sale",
	1: "purchase",
	2: "return",
	3: "adjustment",
	4: "loss",
	5: "damage",
}

type InventoryTransactions struct {
	core.BaseRecordProxy
}

func (p *InventoryTransactions) CollectionName() string {
	return "inventory_transactions"
}

func (p *InventoryTransactions) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *InventoryTransactions) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *InventoryTransactions) Sku() *Skus {
	var proxy *Skus
	if rel := p.ExpandedOne("sku"); rel != nil {
		proxy = &Skus{}
		proxy.Record = rel
	}
	return proxy
}

func (p *InventoryTransactions) SetSku(sku *Skus) {
	var id string
	if sku != nil {
		id = sku.Id
	}
	p.Record.Set("sku", id)
	e := p.Expand()
	if sku != nil {
		e["sku"] = sku.Record
	} else {
		delete(e, "sku")
	}
	p.SetExpand(e)
}

func (p *InventoryTransactions) QuantityChange() float64 {
	return p.GetFloat("quantity_change")
}

func (p *InventoryTransactions) SetQuantityChange(quantityChange float64) {
	p.Set("quantity_change", quantityChange)
}

func (p *InventoryTransactions) QuantityAfter() float64 {
	return p.GetFloat("quantity_after")
}

func (p *InventoryTransactions) SetQuantityAfter(quantityAfter float64) {
	p.Set("quantity_after", quantityAfter)
}

func (p *InventoryTransactions) TransactionDate() types.DateTime {
	return p.GetDateTime("transaction_date")
}

func (p *InventoryTransactions) SetTransactionDate(transactionDate types.DateTime) {
	p.Set("transaction_date", transactionDate)
}

func (p *InventoryTransactions) ReasonCode() ReasonCodeSelectType {
	option := p.GetString("reason_code")
	i, ok := zzReasonCodeSelectTypeSelectNameMap[option]
	if !ok {
		panic("Unknown select value")
	}
	return i
}

func (p *InventoryTransactions) SetReasonCode(reasonCode ReasonCodeSelectType) {
	i, ok := zzReasonCodeSelectTypeSelectIotaMap[reasonCode]
	if !ok {
		panic("Unknown select value")
	}
	p.Set("reason_code", i)
}

func (p *InventoryTransactions) ReferenceId() string {
	return p.GetString("reference_id")
}

func (p *InventoryTransactions) SetReferenceId(referenceId string) {
	p.Set("reference_id", referenceId)
}

func (p *InventoryTransactions) ReferenceType() string {
	return p.GetString("reference_type")
}

func (p *InventoryTransactions) SetReferenceType(referenceType string) {
	p.Set("reference_type", referenceType)
}

func (p *InventoryTransactions) User() *Users {
	var proxy *Users
	if rel := p.ExpandedOne("user"); rel != nil {
		proxy = &Users{}
		proxy.Record = rel
	}
	return proxy
}

func (p *InventoryTransactions) SetUser(user *Users) {
	var id string
	if user != nil {
		id = user.Id
	}
	p.Record.Set("user", id)
	e := p.Expand()
	if user != nil {
		e["user"] = user.Record
	} else {
		delete(e, "user")
	}
	p.SetExpand(e)
}

func (p *InventoryTransactions) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *InventoryTransactions) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *InventoryTransactions) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *InventoryTransactions) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}

type ProductAnalytics struct {
	core.BaseRecordProxy
}

func (p *ProductAnalytics) CollectionName() string {
	return "product_analytics"
}

func (p *ProductAnalytics) Product() *Products {
	var proxy *Products
	if rel := p.ExpandedOne("product"); rel != nil {
		proxy = &Products{}
		proxy.Record = rel
	}
	return proxy
}

func (p *ProductAnalytics) SetProduct(product *Products) {
	var id string
	if product != nil {
		id = product.Id
	}
	p.Record.Set("product", id)
	e := p.Expand()
	if product != nil {
		e["product"] = product.Record
	} else {
		delete(e, "product")
	}
	p.SetExpand(e)
}

func (p *ProductAnalytics) Period() string {
	return p.GetString("period")
}

func (p *ProductAnalytics) SetPeriod(period string) {
	p.Set("period", period)
}

func (p *ProductAnalytics) Company() *Companies {
	var proxy *Companies
	if rel := p.ExpandedOne("company"); rel != nil {
		proxy = &Companies{}
		proxy.Record = rel
	}
	return proxy
}

func (p *ProductAnalytics) SetCompany(company *Companies) {
	var id string
	if company != nil {
		id = company.Id
	}
	p.Record.Set("company", id)
	e := p.Expand()
	if company != nil {
		e["company"] = company.Record
	} else {
		delete(e, "company")
	}
	p.SetExpand(e)
}

func (p *ProductAnalytics) UnitsSold() float64 {
	return p.GetFloat("units_sold")
}

func (p *ProductAnalytics) SetUnitsSold(unitsSold float64) {
	p.Set("units_sold", unitsSold)
}

func (p *ProductAnalytics) Revenue() float64 {
	return p.GetFloat("revenue")
}

func (p *ProductAnalytics) SetRevenue(revenue float64) {
	p.Set("revenue", revenue)
}

func (p *ProductAnalytics) Cost() float64 {
	return p.GetFloat("cost")
}

func (p *ProductAnalytics) SetCost(cost float64) {
	p.Set("cost", cost)
}

func (p *ProductAnalytics) Profit() float64 {
	return p.GetFloat("profit")
}

func (p *ProductAnalytics) SetProfit(profit float64) {
	p.Set("profit", profit)
}

func (p *ProductAnalytics) AvgSellingPrice() float64 {
	return p.GetFloat("avg_selling_price")
}

func (p *ProductAnalytics) SetAvgSellingPrice(avgSellingPrice float64) {
	p.Set("avg_selling_price", avgSellingPrice)
}

func (p *ProductAnalytics) Created() types.DateTime {
	return p.GetDateTime("created")
}

func (p *ProductAnalytics) SetCreated(created types.DateTime) {
	p.Set("created", created)
}

func (p *ProductAnalytics) Updated() types.DateTime {
	return p.GetDateTime("updated")
}

func (p *ProductAnalytics) SetUpdated(updated types.DateTime) {
	p.Set("updated", updated)
}
